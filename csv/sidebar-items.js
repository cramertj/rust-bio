initSidebarItems({"enum":[["Error","An error produced by an operation on CSV data."],["NextField","NextField is the result of parsing a single CSV field.This is only useful if you're using the low level `next_bytes` method."],["ParseError","A description of a CSV parse error."],["QuoteStyle","The quoting style to use when writing CSV data."],["RecordTerminator","A record terminator.Ideally, this would just be a `u8` like any other delimiter, but a useful CSV parser must special case CRLF handling. Hence, this enum.Generally, you won't need to use this type because `CRLF` is the default, which is by far the most widely used record terminator."]],"mod":[["index","This sub-module provides experimental CSV record indexing.It is simplistic, but once a CSV index is created, you can use it to jump to any record in the data instantly. In essence, it gives you random access for a modest upfront cost in time and memory.Simple exampleThis example shows how to create an in-memory index and use it to jump to any record in the data. (The indexing interface works with seekable readers and writers, so you can use `std::fs::File` for this too.)"]],"struct":[["ByteRecords","An iterator of `ByteString` records.The lifetime parameter `'a` refers to the lifetime of the underlying CSV reader.The `R` type parameter refers to the type of the underlying reader."],["Decoded","A record to be decoded.This is a \"wrapper\" type that allows the `Decoder` machinery from the `serialize` crate to decode a *single* CSV record into your custom types.Generally, you should not need to use this type directly. Instead, you should prefer the `decode` or `decode_all` methods defined on `CsvReader`."],["DecodedRecords","An iterator of decoded records.The lifetime parameter `'a` refers to the lifetime of the underlying CSV reader.The `R` type parameter refers to the type of the underlying reader.The `D` type parameter refers to the decoded type."],["Encoded","A record to be encoded.This is a \"wrapper\" type that allows the `Encoder` machinery from the `serialize` crate to encode a *single* CSV record from your custom types.Generally, you should not need to use this type directly. Instead, you should prefer the `encode` or `encode_all` methods defined on `CsvWriter`."],["LocatableError","An error tagged with a location at which it occurred."],["Reader","A CSV reader.This reader parses CSV data and exposes records via iterators.ExampleThis example shows how to do type-based decoding for each record in the CSV data.Here's another example that parses tab-delimited values with records of varying length:"],["StringRecords","An iterator of `String` records.The lifetime parameter `'a` refers to the lifetime of the underlying CSV reader.The `R` type parameter refers to the type of the underlying reader."],["Writer","A CSV writer.This writer provides a convenient interface for encoding CSV data. While creating CSV data is much easier than parsing it, having a writer can be convenient because it can handle quoting for you automatically. Moreover, this particular writer supports `Encodable` types, which makes it easy to write your custom types as CSV records.All CSV data produced by this writer, with default options, conforms with RFC 4180. (If certain options like flexible record lengths are enabled, then compliance with RFC 4180 cannot be guaranteed.)One slight deviation is that records with a single empty field are always encoded as `\"\"`. This ensures that the record is not skipped since some CSV parsers will ignore consecutive record terminators (like the one in this crate).ExampleHere's an example that encodes word pairs and their edit distances:"]],"trait":[["BorrowBytes","A trait that permits borrowing byte vectors.This is useful for providing an API that can abstract over Unicode strings and byte strings."]],"type":[["ByteString","A convenience type for referring to a plain byte string."],["Result","A convenience type for representing the result of most CSV reader/writer operations."]]});