initSidebarItems({"mod":[["bndm","Backward nondeterministic DAWG matching (BNDM). Best-case complexity: O(n / m) with pattern of length m <= 64 and text of length n. Worst case complexity: O(n * m).Example"],["bom","Backward oracle matching algorithm. Best-case complexity: O(n / m) with pattern of length m and text of length n. Worst case complexity: O(n * m).Example"],["horspool","Algorithm of Horspool. Window-based, similar to but faster than Boyer-Moore.IdeaLook at a search window m, match pattern backwards. In case of a mismatch, you can jump behind that. Best case time complexity: O(n / m) Worst case time complexity: O(n * m) With a large alphabet, you are likely around the best case, and faster than the rather complicated Boyer-Moore.The algorithm has two phases (let a be the last symbol in the window):test phase: compare the last symbol of the window. If it matches, compare the whole pattern. If it does not match, continue with the shift phase. shift phase: let l[a] be the rightmost position of a in the pattern without the last symbol. If it does not occur let l[a] be -1. Shift the window by m - 1 - l[a]. I.e. we shift the window such that the rightmost a matches the a at the end of the last window. If a does not occur in the pattern, we shift by the whole length. Example"],["kmp","Algorithm of Knuth Morris and Pratt. Constructs an automaton recognizing the pattern, and scans linearly over a text of length n. Complexity: O(n). The transition function delta is simulated via the lps-function, that assigns to each position q in the pattern the longest prefix of the pattern that is suffix of pattern[..q+1]. Then, in the NFA for the pattern, active states after reading position q are {q, lps(q), lps(lps(q)), ... 0}.Example"],["myers","Myers bit-parallel approximate pattern matching algorithm. Finds all matches up to a given edit distance. The pattern has to fit into a bitvector, and is here limited to 64 symbols. Complexity: O(n)Example"],["shift_and","ShiftAnd algorithm for pattern matching. Patterns may contain at most 64 symbols. Complexity: O(n) with text length n.Example"],["ukkonen","Bounded version of Ukkonens DP algorithm for approximate pattern matching. Complexity: O(n * k) on random texts.The algorithm finds all matches of a pattern in a text with up to k errors. Idea is to use dynamic programming to column-wise explore the edit matrix, but to omit parts of the matrix for which the error exceeds k. To achieve this, a value `lastk` is maintained that provides the lower feasible boundary of the matrix. Initially, lastk = min(k, m). In each iteration (over a column), lastk can increase by at most 1.Example"]]});